{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tweakcn-switcher",
  "title": "Tweakcn Switcher",
  "description": "A component for switching shadcn/ui themes dynamically from tweakcn.com",
  "registryDependencies": [
    "button",
    "input",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "registry/tweakcn-switcher/tweakcn-switcher.tsx",
      "content": "/**\n * TweakcnSwitcher - A component for switching shadcn/ui themes\n */\n\nimport { Palette, Loader2, Plus, X, Moon, Sun } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n} from \"@/components/ui/dropdown-menu\";\nimport { useTweakcnSwitcher } from \"./use-tweakcn-switcher\";\nimport type { TweakcnSwitcherConfig } from \"./types\";\nimport { cn } from \"@/lib/utils\";\nimport { type KeyboardEvent, useState } from \"react\";\n\nexport interface TweakcnSwitcherProps extends TweakcnSwitcherConfig {\n  className?: string;\n  align?: \"start\" | \"center\" | \"end\";\n}\n\nexport function TweakcnSwitcher({ className, align = \"end\", ...config }: TweakcnSwitcherProps) {\n  const {\n    currentTheme,\n    themes,\n    isLoading,\n    error,\n    applyThemeOption,\n    addTheme,\n    removeTheme,\n    mode,\n    setMode,\n  } = useTweakcnSwitcher(config);\n\n  const [urlInput, setUrlInput] = useState(\"\");\n  const [isAddingTheme, setIsAddingTheme] = useState(false);\n  const [showUrlInput, setShowUrlInput] = useState(false);\n\n  const handleAddTheme = async () => {\n    if (!urlInput.trim()) return;\n\n    setIsAddingTheme(true);\n    try {\n      const newTheme = await addTheme(urlInput.trim());\n      if (newTheme !== null) {\n        await applyThemeOption(newTheme);\n      }\n      setUrlInput(\"\");\n      setShowUrlInput(false);\n    } catch (err) {\n      console.error(\"Failed to add theme:\", err);\n    } finally {\n      setIsAddingTheme(false);\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      handleAddTheme();\n    } else if (e.key === \"Escape\") {\n      setShowUrlInput(false);\n      setUrlInput(\"\");\n    }\n  };\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger\n        render={\n          <Button\n            variant=\"outline\"\n            size=\"icon\"\n            className={cn(\"relative\", className)}\n            aria-label=\"Switch theme\"\n          >\n            <Palette className=\"size-4\" />\n            {currentTheme && (\n              <span className=\"absolute -top-1 -right-1 size-2 bg-primary rounded-full\" />\n            )}\n          </Button>\n        }\n      />\n      <DropdownMenuContent align={align} className=\"w-64\">\n        <DropdownMenuGroup>\n          <DropdownMenuLabel className=\"flex items-center justify-between\">\n            <span>Themes</span>\n            <div className=\"flex items-center gap-1\">\n              <Button\n                variant=\"ghost\"\n                size=\"icon-xs\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  setMode(mode === \"light\" ? \"dark\" : \"light\");\n                }}\n                className=\"h-6 w-6\"\n                aria-label={`Switch to ${mode === \"light\" ? \"dark\" : \"light\"} mode`}\n              >\n                {mode === \"light\" ? <Moon className=\"size-3\" /> : <Sun className=\"size-3\" />}\n              </Button>\n            </div>\n          </DropdownMenuLabel>\n          <DropdownMenuSeparator />\n\n          {error && <div className=\"px-2 py-1.5 text-xs text-destructive\">{error}</div>}\n\n          {showUrlInput ? (\n            <div className=\"px-2 py-1.5 space-y-2\">\n              <Input\n                placeholder=\"https://tweakcn.com/r/themes/...\"\n                value={urlInput}\n                onChange={(e) => setUrlInput(e.target.value)}\n                onKeyDown={handleKeyDown}\n                className=\"h-7 text-xs\"\n                autoFocus\n              />\n              <div className=\"flex gap-1\">\n                <Button\n                  variant=\"default\"\n                  size=\"xs\"\n                  onClick={handleAddTheme}\n                  disabled={isAddingTheme || !urlInput.trim()}\n                  className=\"flex-1 h-6\"\n                >\n                  {isAddingTheme ? (\n                    <Loader2 className=\"size-3 animate-spin\" />\n                  ) : (\n                    <Plus className=\"size-3\" />\n                  )}\n                  Add\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"xs\"\n                  onClick={() => {\n                    setShowUrlInput(false);\n                    setUrlInput(\"\");\n                  }}\n                  className=\"h-6\"\n                >\n                  Cancel\n                </Button>\n              </div>\n            </div>\n          ) : (\n            <>\n              {themes.length > 0 ? (\n                <DropdownMenuRadioGroup\n                  value={currentTheme?.id}\n                  onValueChange={(value) => {\n                    const theme = themes.find((t) => t.id === value);\n                    if (theme) {\n                      applyThemeOption(theme);\n                    }\n                  }}\n                >\n                  {themes.map((theme) => (\n                    <DropdownMenuRadioItem\n                      key={theme.id}\n                      value={theme.id}\n                      className=\"flex items-center justify-between group\"\n                    >\n                      <span className=\"truncate flex-1\">{theme.name}</span>\n                      {themes.length > (config.defaultThemes?.length || 0) && (\n                        <Button\n                          variant=\"ghost\"\n                          size=\"icon-xs\"\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            removeTheme(theme.id);\n                          }}\n                          className=\"h-5 w-5 opacity-0 group-hover:opacity-100 transition-opacity\"\n                          aria-label={`Remove ${theme.name}`}\n                        >\n                          <X className=\"size-3\" />\n                        </Button>\n                      )}\n                    </DropdownMenuRadioItem>\n                  ))}\n                </DropdownMenuRadioGroup>\n              ) : (\n                <div className=\"px-2 py-4 text-xs text-muted-foreground text-center\">\n                  No themes available\n                </div>\n              )}\n            </>\n          )}\n\n          {isLoading && (\n            <div className=\"px-2 py-1.5 flex items-center gap-2 text-xs text-muted-foreground\">\n              <Loader2 className=\"size-3 animate-spin\" />\n              Loading theme...\n            </div>\n          )}\n        </DropdownMenuGroup>\n\n        {!showUrlInput && (\n          <>\n            <DropdownMenuSeparator />\n            <DropdownMenuItem onClick={() => setShowUrlInput(true)} className=\"cursor-pointer\">\n              <Plus className=\"size-4 mr-2\" />\n              Add theme from URL\n            </DropdownMenuItem>\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "registry/tweakcn-switcher/use-tweakcn-switcher.ts",
      "content": "/**\n * Hook for managing shadcn/ui theme switching\n */\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport type { ThemeRegistryItem, ThemeOption, TweakcnSwitcherConfig } from \"./types\";\nimport { applyThemeFromRegistry, fetchThemeFromUrl, extractThemeNameFromUrl } from \"./utils\";\n\nexport interface UseTweakcnSwitcherReturn {\n  currentTheme: ThemeOption | null;\n  themes: ThemeOption[];\n  isLoading: boolean;\n  error: string | null;\n  applyTheme: (url: string) => Promise<void>;\n  applyThemeOption: (theme: ThemeOption) => Promise<void>;\n  addTheme: (url: string, name?: string) => Promise<ThemeOption | null>;\n  removeTheme: (themeId: string) => void;\n  mode: \"light\" | \"dark\";\n  setMode: (mode: \"light\" | \"dark\") => void;\n}\n\nconst DEFAULT_STORAGE_KEY = \"tweakcn-switcher-theme\";\n\nexport function useTweakcnSwitcher(config: TweakcnSwitcherConfig = {}): UseTweakcnSwitcherReturn {\n  const { defaultThemes = [], persist = true, storageKey = DEFAULT_STORAGE_KEY } = config;\n\n  const [themes, setThemes] = useState<ThemeOption[]>(defaultThemes);\n  const [currentTheme, setCurrentTheme] = useState<ThemeOption | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [mode, setMode] = useState<\"light\" | \"dark\">(\"light\");\n  const [currentRegistryItem, setCurrentRegistryItem] = useState<ThemeRegistryItem | null>(null);\n\n  const applyTheme = useCallback(\n    async (url: string) => {\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const registryItem = await fetchThemeFromUrl(url);\n        setCurrentRegistryItem(registryItem);\n        await applyThemeFromRegistry(registryItem, mode);\n\n        // Find or create theme option\n        const themeName = registryItem.name || extractThemeNameFromUrl(url);\n        const themeId = `theme-${themeName}`;\n\n        setThemes((prev) => {\n          let themeOption = prev.find((t) => t.url === url);\n          if (!themeOption) {\n            themeOption = {\n              id: themeId,\n              name: themeName,\n              url,\n            };\n            const updated = [...prev, themeOption];\n            setCurrentTheme(themeOption);\n            return updated;\n          }\n          setCurrentTheme(themeOption);\n          return prev;\n        });\n\n        // Persist if enabled\n        if (persist) {\n          localStorage.setItem(storageKey, JSON.stringify({ url, mode, name: themeName }));\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : \"Failed to apply theme\";\n        setError(errorMessage);\n        console.error(\"Failed to apply theme:\", err);\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [mode, persist, storageKey],\n  );\n\n  // Load persisted theme on mount\n  useEffect(() => {\n    if (persist) {\n      const saved = localStorage.getItem(storageKey);\n      if (saved) {\n        try {\n          const savedTheme = JSON.parse(saved);\n          if (savedTheme.mode) {\n            setMode(savedTheme.mode);\n          }\n          if (savedTheme.url) {\n            // Apply theme after mode is set\n            setTimeout(() => {\n              applyTheme(savedTheme.url).catch(console.error);\n            }, 0);\n          }\n        } catch (e) {\n          console.error(\"Failed to load saved theme:\", e);\n        }\n      }\n    }\n  }, [persist, storageKey, applyTheme]);\n\n  // Apply mode changes to current theme\n  useEffect(() => {\n    if (currentRegistryItem) {\n      applyThemeFromRegistry(currentRegistryItem, mode).catch(console.error);\n    }\n  }, [mode, currentRegistryItem]);\n\n  const applyThemeOption = useCallback(\n    async (theme: ThemeOption) => {\n      await applyTheme(theme.url);\n    },\n    [applyTheme],\n  );\n\n  const addTheme = useCallback(async (url: string, name?: string): Promise<ThemeOption | null> => {\n    try {\n      const registryItem = await fetchThemeFromUrl(url);\n      const themeName = name || registryItem.name || extractThemeNameFromUrl(url);\n      const themeId = `theme-${themeName}`;\n\n      const newTheme: ThemeOption = {\n        id: themeId,\n        name: themeName,\n        url,\n      };\n\n      setThemes((prev) => {\n        if (prev.some((t) => t.url === url)) {\n          return prev;\n        }\n        return [...prev, newTheme];\n      });\n\n      return newTheme;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : \"Failed to add theme\";\n      setError(errorMessage);\n      throw err;\n    }\n  }, []);\n\n  const removeTheme = useCallback(\n    (themeId: string) => {\n      setThemes((prev) => prev.filter((t) => t.id !== themeId));\n      if (currentTheme?.id === themeId) {\n        setCurrentTheme(null);\n        setCurrentRegistryItem(null);\n        if (persist) {\n          localStorage.removeItem(storageKey);\n        }\n      }\n    },\n    [currentTheme, persist, storageKey],\n  );\n\n  return {\n    currentTheme,\n    themes,\n    isLoading,\n    error,\n    applyTheme,\n    applyThemeOption,\n    addTheme,\n    removeTheme,\n    mode,\n    setMode,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/tweakcn-switcher/types.ts",
      "content": "/**\n * Type definitions for shadcn/ui theme registry format\n */\n\nexport interface ThemeRegistryCssVars {\n  theme?: Record<string, string>;\n  light?: Record<string, string>;\n  dark?: Record<string, string>;\n}\n\nexport interface ThemeRegistryItem {\n  $schema?: string;\n  name: string;\n  type: string;\n  css?: {\n    \"@layer base\"?: Record<string, Record<string, string>>;\n  };\n  cssVars: ThemeRegistryCssVars;\n}\n\nexport interface ThemeOption {\n  id: string;\n  name: string;\n  url?: string;\n  css?: string;\n  preview?: string;\n}\n\nexport interface TweakcnSwitcherConfig {\n  defaultThemes?: ThemeOption[];\n  baseUrl?: string;\n  persist?: boolean;\n  storageKey?: string;\n}\n\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/tweakcn-switcher/utils.ts",
      "content": "/// <reference lib=\"dom\" />\n/**\n * Utility functions for applying theme CSS variables\n */\n\nimport type { ThemeRegistryItem, ThemeRegistryCssVars } from \"./types\";\n\nfunction applyCSSVariable(\n  key: string,\n  value: string,\n  root: HTMLElement | null = typeof document !== \"undefined\" ? document.documentElement : null,\n) {\n  if (!root) return;\n  // Use setProperty for CSS custom properties - more reliable than manipulating style attribute\n  root.style.setProperty(`--${key}`, value);\n}\n\n/**\n * Remove all font links added by tweakcn-switcher\n */\nfunction removeFontLinks() {\n  if (typeof document === \"undefined\") return;\n  const existing = document.querySelectorAll('link[data-tweakcn-switcher-font=\"true\"]');\n  existing.forEach((el: Element) => el.remove());\n}\n\n/**\n * Extract font family names from a font-family CSS value\n * Handles values like \"Roboto, sans-serif\" or '\"Inter Variable\", sans-serif'\n */\nfunction extractFontNames(fontFamily: string): string[] {\n  // Remove quotes and split by comma\n  const fonts = fontFamily\n    .split(\",\")\n    .map((f) => f.trim().replace(/^[\"']|[\"']$/g, \"\"))\n    .filter((f) => f && !f.match(/^(sans-serif|serif|monospace| cursive|fantasy)$/i));\n\n  return fonts;\n}\n\n/**\n * Try to load a font from Google Fonts\n * Returns the Google Fonts URL if successful, null otherwise\n */\nfunction getGoogleFontsUrl(fontName: string): string | null {\n  // Remove spaces and special characters for Google Fonts API\n  const normalizedName = fontName.replace(/\\s+/g, \"+\").replace(/['\"]/g, \"\").trim();\n\n  if (!normalizedName) {\n    return null;\n  }\n\n  // Google Fonts API URL\n  return `https://fonts.googleapis.com/css2?family=${normalizedName}:wght@400;500;600;700&display=swap`;\n}\n\n/**\n * Load a font from Google Fonts URL\n */\nfunction loadGoogleFont(url: string): Promise<void> {\n  if (typeof document === \"undefined\") {\n    return Promise.resolve();\n  }\n\n  return new Promise<void>((resolve) => {\n    // Check if link already exists\n    const existing = document.querySelector(`link[href=\"${url}\"]`);\n    if (existing) {\n      resolve();\n      return;\n    }\n\n    const link = document.createElement(\"link\");\n    link.rel = \"stylesheet\";\n    link.href = url;\n    link.setAttribute(\"data-tweakcn-switcher-font\", \"true\");\n\n    link.onload = () => resolve();\n    link.onerror = () => {\n      // Silently fail - let the dev handle it if needed\n      resolve();\n    };\n\n    document.head.appendChild(link);\n  });\n}\n\n/**\n * Try to load fonts from Google Fonts based on font-family value\n * This is best-effort - if it fails, the dev can handle it\n */\nasync function tryLoadFontsFromGoogleFonts(fontFamily: string): Promise<void> {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  const fontNames = extractFontNames(fontFamily);\n\n  if (fontNames.length === 0) {\n    return;\n  }\n\n  // Try to load each font from Google Fonts\n  const loadPromises = fontNames.map((fontName) => {\n    const googleFontsUrl = getGoogleFontsUrl(fontName);\n    if (googleFontsUrl) {\n      return loadGoogleFont(googleFontsUrl);\n    }\n    return Promise.resolve();\n  });\n\n  await Promise.all(loadPromises);\n}\n\nexport async function applyThemeFromRegistry(\n  registryItem: ThemeRegistryItem,\n  mode: \"light\" | \"dark\" = \"light\",\n) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  const root = document.documentElement;\n  const { cssVars, css } = registryItem;\n\n  // Remove existing font variable override styles\n  const existingFontStyle = document.querySelector('style[data-tweakcn-switcher-font-vars=\"true\"]');\n  if (existingFontStyle) {\n    existingFontStyle.remove();\n  }\n\n  // Apply theme-level variables (common to both light and dark)\n  let fontSansValue: string | null = null;\n  if (cssVars.theme) {\n    Object.entries(cssVars.theme).forEach(([key, value]) => {\n      applyCSSVariable(key, value, root);\n\n      // Track font-sans value for special handling\n      if (key === \"font-sans\" && value) {\n        fontSansValue = value;\n      }\n    });\n  }\n\n  // Try to load fonts from Google Fonts if font-sans is set\n  if (fontSansValue) {\n    // Try to load from Google Fonts (best-effort, fails silently)\n    await tryLoadFontsFromGoogleFonts(fontSansValue).catch(() => {\n      // Silently fail - let the dev handle font loading if needed\n    });\n\n    // Inject a style to override Tailwind's @theme variable with higher specificity\n    const fontStyle = document.createElement(\"style\");\n    fontStyle.setAttribute(\"data-tweakcn-switcher-font-vars\", \"true\");\n    // Escape any quotes in the font value for CSS\n    const escapedFontValue = (fontSansValue as string).replace(/\"/g, '\\\\\"');\n    fontStyle.textContent = `\n      :root {\n        --font-sans: ${escapedFontValue} !important;\n      }\n      html, body {\n        font-family: ${escapedFontValue} !important;\n      }\n    `;\n    document.head.appendChild(fontStyle);\n  } else {\n    // If no font-sans in theme, remove any inline font-family styles we may have set\n    removeFontLinks();\n    root.style.removeProperty(\"font-family\");\n    if (document.body) {\n      document.body.style.removeProperty(\"font-family\");\n    }\n  }\n\n  // Apply mode-specific variables (excluding theme-level variables)\n  const modeVars = cssVars[mode];\n  if (modeVars) {\n    Object.entries(modeVars).forEach(([key, value]) => {\n      // Skip theme-level variables (radius, font-*, shadow, tracking-*, spacing)\n      // These should only come from cssVars.theme\n      if (\n        !key.startsWith(\"font-\") &&\n        !key.startsWith(\"radius\") &&\n        !key.startsWith(\"shadow\") &&\n        !key.startsWith(\"tracking-\") &&\n        !key.startsWith(\"spacing\")\n      ) {\n        applyCSSVariable(key, value, root);\n      }\n    });\n  }\n\n  // Apply CSS layer base styles if present\n  if (css?.[\"@layer base\"]) {\n    // Remove existing style elements\n    const existing = document.querySelectorAll('style[data-tweakcn-switcher=\"true\"]');\n    existing.forEach((el: Element) => el.remove());\n\n    const baseStyles = css[\"@layer base\"];\n    const styleElement = document.createElement(\"style\");\n    styleElement.setAttribute(\"data-tweakcn-switcher\", \"true\");\n\n    // Combine all selectors into one style element\n    const styleContent = Object.entries(baseStyles)\n      .map(([selector, styles]) => {\n        const props = Object.entries(styles)\n          .map(([prop, val]) => `${prop}: ${val};`)\n          .join(\" \");\n        return `${selector} { ${props} }`;\n      })\n      .join(\"\\n\");\n\n    styleElement.textContent = `@layer base {\\n${styleContent}\\n}`;\n    document.head.appendChild(styleElement);\n  }\n\n  if (mode === \"dark\") {\n    root.classList.add(\"dark\");\n  } else {\n    root.classList.remove(\"dark\");\n  }\n}\n\nexport async function fetchThemeFromUrl(url: string): Promise<ThemeRegistryItem> {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch theme: ${response.statusText}`);\n  }\n  const data = await response.json();\n  return data as ThemeRegistryItem;\n}\n\nexport function extractThemeNameFromUrl(url: string): string {\n  const match = url.match(/\\/([^/]+)\\.json$/);\n  return match && match[1] ? match[1] : \"custom-theme\";\n}\n\n/**\n * Parses CSS code and converts it to a ThemeRegistryItem\n * Supports :root, .dark, and @theme inline selectors\n */\nexport function parseCssToThemeRegistryItem(\n  css: string,\n  name: string = \"custom-css-theme\",\n): ThemeRegistryItem {\n  const cssVars: ThemeRegistryCssVars = {\n    theme: {},\n    light: {},\n    dark: {},\n  };\n\n  // Remove comments\n  const cleanedCss = css.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n\n  // Parse :root selector (light mode variables)\n  const rootMatch = cleanedCss.match(/:root\\s*\\{([^}]+)\\}/);\n  if (rootMatch && rootMatch[1]) {\n    const rootContent = rootMatch[1];\n    const varMatches = rootContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Determine if it's a theme-level variable or light mode variable\n        // Theme-level variables are things like --radius, --font-*, --shadow-*, etc.\n        if (\n          key.startsWith(\"font-\") ||\n          key.startsWith(\"radius\") ||\n          key.startsWith(\"shadow\") ||\n          key.startsWith(\"tracking-\") ||\n          key.startsWith(\"spacing\")\n        ) {\n          cssVars.theme![key] = value;\n        } else {\n          cssVars.light![key] = value;\n        }\n      }\n    }\n  }\n\n  // Parse .dark selector (dark mode variables)\n  const darkMatch = cleanedCss.match(/\\.dark\\s*\\{([^}]+)\\}/);\n  if (darkMatch && darkMatch[1]) {\n    const darkContent = darkMatch[1];\n    const varMatches = darkContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Dark mode variables (excluding theme-level ones)\n        if (\n          !key.startsWith(\"font-\") &&\n          !key.startsWith(\"radius\") &&\n          !key.startsWith(\"shadow\") &&\n          !key.startsWith(\"tracking-\") &&\n          !key.startsWith(\"spacing\")\n        ) {\n          cssVars.dark![key] = value;\n        }\n      }\n    }\n  }\n\n  // Parse @theme inline block if present\n  const themeInlineMatch = cleanedCss.match(/@theme\\s+inline\\s*\\{([^}]+)\\}/);\n  const cssLayerBase: Record<string, Record<string, string>> = {};\n  if (themeInlineMatch && themeInlineMatch[1]) {\n    const themeContent = themeInlineMatch[1];\n    const varMatches = themeContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Check if it's a theme-level variable (radius, font, shadow, etc.)\n        if (\n          key.startsWith(\"font-\") ||\n          key.startsWith(\"radius\") ||\n          key.startsWith(\"shadow\") ||\n          key.startsWith(\"tracking-\") ||\n          key.startsWith(\"spacing\")\n        ) {\n          // Add to theme-level variables\n          cssVars.theme![key] = value;\n        } else {\n          // These are typically color mappings, add to :root in @layer base\n          if (!cssLayerBase[\":root\"]) {\n            cssLayerBase[\":root\"] = {};\n          }\n          cssLayerBase[\":root\"][`--${key}`] = value;\n        }\n      }\n    }\n  }\n\n  return {\n    name,\n    type: \"theme\",\n    cssVars,\n    ...(Object.keys(cssLayerBase).length > 0 && {\n      css: {\n        \"@layer base\": cssLayerBase,\n      },\n    }),\n  };\n}\n\n/**\n * Checks if a string is likely CSS code (contains CSS selectors or properties)\n */\nexport function isCssCode(input: string): boolean {\n  const trimmed = input.trim();\n  // If it's a valid URL, it's not CSS\n  try {\n    new URL(trimmed);\n    return false;\n  } catch {\n    // Not a valid URL, check for CSS indicators\n    return (\n      trimmed.includes(\":root\") ||\n      trimmed.includes(\".dark\") ||\n      trimmed.includes(\"@theme\") ||\n      trimmed.includes(\"--\") ||\n      (trimmed.includes(\"{\") && trimmed.includes(\"}\") && trimmed.includes(\":\"))\n    );\n  }\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}