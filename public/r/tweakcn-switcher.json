{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tweakcn-switcher",
  "title": "Tweakcn Switcher",
  "description": "A component for switching shadcn/ui themes dynamically from tweakcn.com with favorites and preview support",
  "registryDependencies": [
    "button",
    "input",
    "dialog",
    "label"
  ],
  "files": [
    {
      "path": "registry/tweakcn-switcher/tweakcn-switcher.tsx",
      "content": "/**\n * TweakcnSwitcher - A component for switching shadcn/ui themes\n */\n\nimport {\n  Palette,\n  Loader2,\n  Plus,\n  X,\n  Moon,\n  Sun,\n  Code,\n  Link,\n  Search,\n  Trash2,\n  Star,\n  Eye,\n} from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport { useTweakcnSwitcher } from \"./use-tweakcn-switcher\";\nimport type { TweakcnSwitcherConfig } from \"./types\";\nimport { cn } from \"@/lib/utils\";\nimport { isCssCode, fetchThemeFromUrl, parseCssToThemeRegistryItem } from \"./utils\";\nimport { type KeyboardEvent, useState, useMemo } from \"react\";\nimport { toast } from \"sonner\";\nimport { ThemePreviewDialog } from \"./theme-preview-dialog\";\nimport type { ThemeRegistryItem } from \"./types\";\n\nexport interface TweakcnSwitcherProps extends TweakcnSwitcherConfig {\n  className?: string;\n  trigger?: React.ReactElement;\n}\n\nexport function TweakcnSwitcher({ className, trigger, ...config }: TweakcnSwitcherProps) {\n  const {\n    currentTheme,\n    themes,\n    error,\n    applyThemeOption,\n    addTheme,\n    removeTheme,\n    mode,\n    setMode,\n    isLoading,\n    toggleFavorite,\n    isFavorite,\n  } = useTweakcnSwitcher(config);\n  const { allowDeleteDefaults = true, defaultThemes = [] } = config;\n\n  const [open, setOpen] = useState(false);\n  const [input, setInput] = useState(\"\");\n  const [title, setTitle] = useState(\"\");\n  const [isAddingTheme, setIsAddingTheme] = useState(false);\n  const [showInput, setShowInput] = useState(false);\n  const [inputMode, setInputMode] = useState<\"url\" | \"css\">(\"url\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [previewOpen, setPreviewOpen] = useState(false);\n  const [previewTheme, setPreviewTheme] = useState<{\n    theme: any;\n    registryItem: ThemeRegistryItem | null;\n  } | null>(null);\n  const [loadingPreview, setLoadingPreview] = useState(false);\n\n  const handleAddTheme = async () => {\n    if (!input.trim()) return;\n\n    setIsAddingTheme(true);\n    try {\n      const newTheme = await addTheme(input.trim(), title.trim() || undefined);\n      if (newTheme !== null) {\n        await applyThemeOption(newTheme);\n        toast.success(\"Theme added successfully!\", {\n          description: `\"${newTheme.name}\" has been added and applied.`,\n        });\n        setInput(\"\");\n        setTitle(\"\");\n        setShowInput(false);\n      }\n    } catch (err) {\n      // Error is already set in the hook's error state, which will be displayed\n      console.error(\"Failed to add theme:\", err);\n      // Keep the input visible so user can fix the input\n    } finally {\n      setIsAddingTheme(false);\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    setInput(e.target.value);\n    // Auto-detect input mode if user pastes CSS\n    if (isCssCode(e.target.value)) {\n      setInputMode(\"css\");\n    } else if (e.target.value.trim().startsWith(\"http\")) {\n      setInputMode(\"url\");\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    if (e.key === \"Enter\" && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      handleAddTheme();\n    } else if (e.key === \"Escape\") {\n      setShowInput(false);\n      setInput(\"\");\n      setTitle(\"\");\n    }\n  };\n\n  // Filter and sort themes: favorites first, then by search query\n  const filteredAndSortedThemes = useMemo(() => {\n    const filtered = themes.filter((theme) =>\n      theme.name.toLowerCase().includes(searchQuery.toLowerCase()),\n    );\n\n    // Sort: favorites first, then alphabetically\n    return filtered.sort((a, b) => {\n      const aIsFavorite = isFavorite(a.id);\n      const bIsFavorite = isFavorite(b.id);\n\n      if (aIsFavorite && !bIsFavorite) return -1;\n      if (!aIsFavorite && bIsFavorite) return 1;\n\n      return a.name.localeCompare(b.name);\n    });\n  }, [themes, searchQuery, isFavorite]);\n\n  const handlePreviewTheme = async (theme: (typeof themes)[0]) => {\n    setLoadingPreview(true);\n    setPreviewOpen(true);\n    setPreviewTheme({ theme, registryItem: null });\n\n    try {\n      let registryItem: ThemeRegistryItem;\n      if (theme.css) {\n        registryItem = parseCssToThemeRegistryItem(theme.css, theme.name);\n      } else if (theme.url) {\n        registryItem = await fetchThemeFromUrl(theme.url);\n      } else {\n        setLoadingPreview(false);\n        return;\n      }\n\n      setPreviewTheme({ theme, registryItem });\n    } catch (err) {\n      console.error(\"Failed to load theme for preview:\", err);\n      toast.error(\"Failed to load theme preview\");\n    } finally {\n      setLoadingPreview(false);\n    }\n  };\n\n  const defaultTrigger = (\n    <Button variant=\"outline\" className={cn(\"relative\", className)} aria-label=\"Switch theme\">\n      <Palette className=\"size-4\" />\n      <span>Switch theme</span>\n    </Button>\n  );\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger render={trigger ?? defaultTrigger} />\n      <DialogContent className=\"sm:max-w-md overflow-x-hidden\" showCloseButton={false}>\n        <DialogHeader className=\"min-w-0\">\n          <DialogTitle className=\"flex items-center justify-between min-w-0 gap-2\">\n            <span className=\"truncate\">Themes</span>\n            <div className=\"flex items-center gap-1 shrink-0\">\n              <Button\n                variant=\"ghost\"\n                size=\"icon-xs\"\n                onClick={() => setMode(mode === \"light\" ? \"dark\" : \"light\")}\n                className=\"h-6 w-6 shrink-0\"\n                aria-label={`Switch to ${mode === \"light\" ? \"dark\" : \"light\"} mode`}\n              >\n                {mode === \"light\" ? <Moon className=\"size-3\" /> : <Sun className=\"size-3\" />}\n              </Button>\n              <DialogClose\n                render={\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon-xs\"\n                    className=\"h-6 w-6 shrink-0\"\n                    aria-label=\"Close dialog\"\n                  >\n                    <X className=\"size-3\" />\n                  </Button>\n                }\n              />\n            </div>\n          </DialogTitle>\n          <DialogDescription>Select a theme or add a new one</DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-4 min-w-0 overflow-x-hidden\">\n          {error && (\n            <div className=\"px-3 py-2 text-sm text-destructive bg-destructive/10 rounded-none border border-destructive/20\">\n              {error}\n            </div>\n          )}\n\n          {showInput ? (\n            <div className=\"space-y-3 min-w-0\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"theme-title\" className=\"text-xs\">\n                  Theme name <span className=\"text-muted-foreground/70\">(optional)</span>\n                </Label>\n                <Input\n                  id=\"theme-title\"\n                  placeholder=\"e.g., My Custom Theme\"\n                  value={title}\n                  onChange={(e) => setTitle(e.target.value)}\n                  className=\"h-9 text-sm w-full min-w-0\"\n                  autoFocus\n                />\n              </div>\n\n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Source type</Label>\n                <div className=\"flex gap-2 min-w-0\">\n                  <Button\n                    variant={inputMode === \"url\" ? \"default\" : \"outline\"}\n                    size=\"sm\"\n                    onClick={() => {\n                      setInputMode(\"url\");\n                      setInput(\"\");\n                    }}\n                    className={cn(\"flex-1 min-w-0\", inputMode === \"url\" && \"border border-primary\")}\n                  >\n                    <Link className=\"size-3 mr-1.5 shrink-0\" />\n                    <span className=\"truncate\">URL</span>\n                  </Button>\n                  <Button\n                    variant={inputMode === \"css\" ? \"default\" : \"outline\"}\n                    size=\"sm\"\n                    onClick={() => {\n                      setInputMode(\"css\");\n                      setInput(\"\");\n                    }}\n                    className={cn(\"flex-1 min-w-0\", inputMode === \"css\" && \"border border-primary\")}\n                  >\n                    <Code className=\"size-3 mr-1.5 shrink-0\" />\n                    <span className=\"truncate\">CSS</span>\n                  </Button>\n                </div>\n              </div>\n\n              <div className=\"space-y-2\">\n                <Label\n                  htmlFor={inputMode === \"url\" ? \"theme-url\" : \"theme-css\"}\n                  className=\"text-xs\"\n                >\n                  {inputMode === \"url\" ? \"Theme URL\" : \"CSS Variables\"}\n                </Label>\n                {inputMode === \"url\" ? (\n                  <div className=\"flex gap-2 min-w-0\">\n                    <Input\n                      id=\"theme-url\"\n                      placeholder=\"https://tweakcn.com/r/themes/...\"\n                      value={input}\n                      onChange={handleInputChange}\n                      onKeyDown={handleKeyDown}\n                      className=\"h-9 text-sm w-full min-w-0\"\n                    />\n                    <Button\n                      variant=\"outline\"\n                      size=\"icon-sm\"\n                      onClick={() => window.open(\"https://tweakcn.com\", \"_blank\")}\n                      title=\"Browse themes on tweakcn.com\"\n                      aria-label=\"Browse themes on tweakcn.com\"\n                      className=\"shrink-0 size-9 cursor-pointer\"\n                    >\n                      <Link className=\"size-4\" />\n                    </Button>\n                  </div>\n                ) : (\n                  <textarea\n                    id=\"theme-css\"\n                    placeholder=\":root {&#10;  --background: 0 0% 100%;&#10;  --foreground: 222.2 84% 4.9%;&#10;  ...&#10;}\"\n                    value={input}\n                    onChange={handleInputChange}\n                    onKeyDown={handleKeyDown}\n                    className={cn(\n                      \"dark:bg-input/30 border-input focus-visible:border-ring focus-visible:ring-ring/50\",\n                      \"h-32 w-full min-w-0 rounded-md border bg-transparent px-3 py-2 text-sm\",\n                      \"transition-colors focus-visible:ring-1 outline-none\",\n                      \"resize-none font-mono\",\n                    )}\n                  />\n                )}\n                <div className=\"flex gap-2 min-w-0 pt-1\">\n                  <Button\n                    onClick={handleAddTheme}\n                    disabled={isAddingTheme || !input.trim()}\n                    className=\"flex-1 min-w-0\"\n                  >\n                    {isAddingTheme ? (\n                      <Loader2 className=\"size-3 animate-spin mr-1.5 shrink-0\" />\n                    ) : (\n                      <Plus className=\"size-3 mr-1.5 shrink-0\" />\n                    )}\n                    <span className=\"truncate\">Add theme</span>\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => {\n                      setShowInput(false);\n                      setInput(\"\");\n                      setTitle(\"\");\n                      setInputMode(\"url\");\n                    }}\n                    className=\"shrink-0\"\n                    disabled={isAddingTheme}\n                  >\n                    Cancel\n                  </Button>\n                </div>\n              </div>\n            </div>\n          ) : (\n            <>\n              <div className=\"relative min-w-0\">\n                <Search className=\"absolute left-2 top-1/2 -translate-y-1/2 size-4 text-muted-foreground\" />\n                <Input\n                  placeholder=\"Search themes...\"\n                  value={searchQuery}\n                  onChange={(e) => setSearchQuery(e.target.value)}\n                  className=\"h-8 text-sm pl-8 w-full min-w-0\"\n                />\n              </div>\n              {filteredAndSortedThemes.length > 0 ? (\n                <div className=\"space-y-1 max-h-[300px] overflow-y-auto overflow-x-hidden min-w-0\">\n                  {filteredAndSortedThemes.map((theme) => (\n                    <button\n                      key={theme.id}\n                      onClick={() => {\n                        // Prevent clicks if already loading or if this is the current theme\n                        if (isLoading || currentTheme?.id === theme.id) {\n                          return;\n                        }\n                        applyThemeOption(theme);\n                      }}\n                      type=\"button\"\n                      className={cn(\n                        \"flex items-center w-full text-start justify-between group px-3 py-2 rounded-md border border-transparent hover:bg-muted hover:border-border transition-colors min-w-0 cursor-pointer\",\n                        currentTheme?.id === theme.id && \"bg-muted border-border\",\n                        (isLoading || currentTheme?.id === theme.id) &&\n                          \"opacity-50 cursor-not-allowed\",\n                      )}\n                    >\n                      <div className=\"flex items-center gap-2 flex-1 min-w-0\">\n                        <Button\n                          variant=\"ghost\"\n                          size=\"icon-xs\"\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            toggleFavorite(theme.id);\n                          }}\n                          className={cn(\n                            \"h-4 w-4 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity\",\n                            isFavorite(theme.id) && \"opacity-100\",\n                          )}\n                          aria-label={\n                            isFavorite(theme.id)\n                              ? `Unfavorite ${theme.name}`\n                              : `Favorite ${theme.name}`\n                          }\n                        >\n                          <Star\n                            className={cn(\n                              \"size-3\",\n                              isFavorite(theme.id)\n                                ? \"fill-yellow-400 text-yellow-400\"\n                                : \"text-muted-foreground\",\n                            )}\n                          />\n                        </Button>\n                        <span\n                          className={cn(\n                            \"text-sm truncate flex-1 min-w-0\",\n                            currentTheme?.id === theme.id ? \"font-medium\" : \"text-muted-foreground\",\n                          )}\n                        >\n                          {theme.name}\n                        </span>\n                      </div>\n                      <div className=\"flex items-center gap-1 shrink-0\">\n                        <Button\n                          variant=\"ghost\"\n                          size=\"icon-xs\"\n                          onClick={async (e) => {\n                            e.stopPropagation();\n                            await handlePreviewTheme(theme);\n                          }}\n                          className=\"h-5 w-5 opacity-0 group-hover:opacity-100 transition-opacity\"\n                          aria-label={`Preview ${theme.name}`}\n                          title=\"Preview theme\"\n                        >\n                          <Eye className=\"size-3\" />\n                        </Button>\n                        {(() => {\n                          // Check if this theme is a default theme\n                          const isDefaultTheme = defaultThemes.some((dt) => dt.id === theme.id);\n                          // Show delete button if allowDeleteDefaults is true (default) or if it's not a default theme\n                          const canDelete = allowDeleteDefaults || !isDefaultTheme;\n                          if (!canDelete) return null;\n                          return (\n                            <Button\n                              variant=\"ghost\"\n                              size=\"icon-xs\"\n                              onClick={async (e) => {\n                                e.stopPropagation();\n                                const wasCurrentTheme = currentTheme?.id === theme.id;\n                                removeTheme(theme.id);\n\n                                // If we deleted the current theme, switch to another one\n                                if (wasCurrentTheme) {\n                                  // Get the remaining themes after deletion\n                                  const remainingThemes = themes.filter((t) => t.id !== theme.id);\n\n                                  if (remainingThemes.length > 0) {\n                                    // Switch to the last theme\n                                    await applyThemeOption(\n                                      remainingThemes[remainingThemes.length - 1],\n                                    );\n                                  } else if (defaultThemes.length > 0) {\n                                    // If no themes remain, switch to the first default theme\n                                    await applyThemeOption(defaultThemes[0]);\n                                  }\n                                  // If no themes and no defaults, do nothing (currentTheme is already null)\n                                }\n                              }}\n                              className=\"h-5 w-5 opacity-0 group-hover:opacity-100 transition-opacity\"\n                              aria-label={`Remove ${theme.name}`}\n                            >\n                              <Trash2 className=\"size-3\" />\n                            </Button>\n                          );\n                        })()}\n                      </div>\n                    </button>\n                  ))}\n                </div>\n              ) : (\n                <div className=\"px-3 py-8 text-sm text-muted-foreground text-center\">\n                  {searchQuery ? \"No themes found\" : \"No themes available\"}\n                </div>\n              )}\n\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setShowInput(true)}\n                className=\"w-full min-w-0\"\n              >\n                <Plus className=\"size-4 mr-2 shrink-0\" />\n                <span className=\"truncate\">Add theme</span>\n              </Button>\n            </>\n          )}\n        </div>\n      </DialogContent>\n\n      {/* Theme Preview Dialog */}\n      <ThemePreviewDialog\n        open={previewOpen}\n        onOpenChange={setPreviewOpen}\n        theme={previewTheme?.theme || null}\n        registryItem={previewTheme?.registryItem || null}\n        mode={mode}\n        isLoading={loadingPreview}\n      />\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/tweakcn-switcher/theme-preview-dialog.tsx",
      "content": "/**\n * ThemePreviewDialog - A dialog to preview theme colors\n */\n\nimport { X, Loader2 } from \"lucide-react\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport type { ThemeRegistryItem, ThemeOption } from \"./types\";\nimport { extractColorSwatches } from \"./utils\";\n\ninterface ThemePreviewDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  theme: ThemeOption | null;\n  registryItem: ThemeRegistryItem | null;\n  mode: \"light\" | \"dark\";\n  isLoading?: boolean;\n}\n\n/**\n * Convert CSS color value to a displayable color\n * Handles formats like: \"0 0% 100%\" (HSL), \"oklch(...)\", hex, rgb, etc.\n */\nfunction cssColorToDisplayColor(cssValue: string): string {\n  const trimmed = cssValue.trim();\n\n  // If it's already a valid color format, return as-is\n  if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"rgb\") || trimmed.startsWith(\"hsl\")) {\n    return trimmed;\n  }\n\n  // Handle HSL format: \"0 0% 100%\" -> \"hsl(0, 0%, 100%)\"\n  const hslMatch = trimmed.match(/^(\\d+(?:\\.\\d+)?)\\s+(\\d+(?:\\.\\d+)?%)\\s+(\\d+(?:\\.\\d+)?%)$/);\n  if (hslMatch) {\n    return `hsl(${hslMatch[1]}, ${hslMatch[2]}, ${hslMatch[3]})`;\n  }\n\n  // Handle oklch format: \"oklch(0.5 0.2 180)\" -> return as-is (browser support)\n  if (trimmed.startsWith(\"oklch\")) {\n    return trimmed;\n  }\n\n  // Default: try to use as-is, or return a fallback\n  return trimmed || \"#000000\";\n}\n\n/**\n * Normalize variable name to a human-readable format\n * e.g., \"primary\" -> \"Primary\", \"background\" -> \"Background\"\n */\nfunction normalizeVariableName(name: string): string {\n  // Handle kebab-case and snake_case\n  return name\n    .split(/[-_]/)\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join(\" \");\n}\n\nexport function ThemePreviewDialog({\n  open,\n  onOpenChange,\n  theme,\n  registryItem,\n  mode,\n  isLoading = false,\n}: ThemePreviewDialogProps) {\n  if (!theme) {\n    return null;\n  }\n\n  const colors = registryItem ? extractColorSwatches(registryItem, mode) : [];\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\" showCloseButton={false}>\n        <DialogHeader className=\"min-w-0\">\n          <DialogTitle className=\"flex items-center justify-between min-w-0 gap-2\">\n            <span className=\"truncate\">{theme.name}</span>\n            <DialogClose\n              render={\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon-xs\"\n                  className=\"h-6 w-6 shrink-0\"\n                  aria-label=\"Close preview\"\n                >\n                  <X className=\"size-3\" />\n                </Button>\n              }\n            />\n          </DialogTitle>\n          <DialogDescription>Color palette preview</DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-4\">\n          {isLoading || !registryItem ? (\n            <div className=\"flex items-center justify-center py-12\">\n              <Loader2 className=\"size-6 animate-spin text-muted-foreground\" />\n            </div>\n          ) : colors.length > 0 ? (\n            <>\n              {/* Color Swatch Grid */}\n              <div className=\"grid grid-cols-4 gap-2\">\n                {colors.map((swatch, index) => {\n                  const displayColor = cssColorToDisplayColor(swatch.value);\n                  const normalizedName = normalizeVariableName(swatch.name);\n                  return (\n                    <div\n                      key={index}\n                      className=\"relative group aspect-square rounded-md border border-border overflow-hidden\"\n                      style={{ backgroundColor: displayColor }}\n                      title={normalizedName}\n                    >\n                      <div className=\"absolute inset-0 bg-gradient-to-br from-transparent to-black/10\" />\n                      <div className=\"absolute bottom-0 left-0 right-0 p-1.5 bg-black/60 text-white text-xs font-medium opacity-0 group-hover:opacity-100 transition-opacity truncate text-center\">\n                        {normalizedName}\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n\n              {/* Color List */}\n              <div className=\"space-y-2\">\n                <div className=\"text-xs font-medium text-muted-foreground\">Color Values</div>\n                <div className=\"space-y-1.5 max-h-[200px] overflow-y-auto\">\n                  {colors.map((swatch, index) => {\n                    const displayColor = cssColorToDisplayColor(swatch.value);\n                    const normalizedName = normalizeVariableName(swatch.name);\n                    return (\n                      <div\n                        key={index}\n                        className=\"flex items-center gap-2 p-2 rounded-md border border-border bg-muted/30\"\n                      >\n                        <div\n                          className=\"size-8 rounded border border-border shrink-0\"\n                          style={{ backgroundColor: displayColor }}\n                        />\n                        <div className=\"flex-1 min-w-0\">\n                          <div className=\"text-xs font-medium text-foreground\">\n                            {normalizedName}\n                          </div>\n                          <code className=\"text-[10px] font-mono text-muted-foreground truncate block\">\n                            {swatch.value}\n                          </code>\n                        </div>\n                      </div>\n                    );\n                  })}\n                </div>\n              </div>\n            </>\n          ) : (\n            <div className=\"py-8 text-sm text-muted-foreground text-center\">\n              No color information available\n            </div>\n          )}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/tweakcn-switcher/use-tweakcn-switcher.ts",
      "content": "/**\n * Hook for managing shadcn/ui theme switching\n */\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport type { ThemeRegistryItem, ThemeOption, TweakcnSwitcherConfig } from \"./types\";\nimport {\n  applyThemeFromRegistry,\n  fetchThemeFromUrl,\n  extractThemeNameFromUrl,\n  validateUrl,\n  parseCssToThemeRegistryItem,\n  isCssCode,\n  normalizeTweakcnUrl,\n} from \"./utils\";\n\nexport interface UseTweakcnSwitcherReturn {\n  currentTheme: ThemeOption | null;\n  themes: ThemeOption[];\n  isLoading: boolean;\n  error: string | null;\n  applyTheme: (url: string) => Promise<void>;\n  applyThemeOption: (theme: ThemeOption) => Promise<void>;\n  addTheme: (url: string, name?: string) => Promise<ThemeOption | null>;\n  removeTheme: (themeId: string) => void;\n  mode: \"light\" | \"dark\";\n  setMode: (mode: \"light\" | \"dark\") => void;\n  favorites: string[];\n  toggleFavorite: (themeId: string) => void;\n  isFavorite: (themeId: string) => boolean;\n}\n\nconst DEFAULT_STORAGE_KEY = \"tweakcn-switcher-theme\";\nconst DEFAULT_FAVORITES_KEY = \"tweakcn-switcher-favorites\";\n\nexport function useTweakcnSwitcher(config: TweakcnSwitcherConfig = {}): UseTweakcnSwitcherReturn {\n  const { defaultThemes = [], persist = true, storageKey = DEFAULT_STORAGE_KEY } = config;\n  const favoritesKey = `${storageKey}-favorites`;\n\n  const [themes, setThemes] = useState<ThemeOption[]>(defaultThemes);\n  const [currentTheme, setCurrentTheme] = useState<ThemeOption | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [mode, setMode] = useState<\"light\" | \"dark\">(\"light\");\n  const [currentRegistryItem, setCurrentRegistryItem] = useState<ThemeRegistryItem | null>(null);\n  const [favorites, setFavorites] = useState<string[]>(() => {\n    if (persist && typeof window !== \"undefined\") {\n      try {\n        const saved = localStorage.getItem(favoritesKey);\n        if (saved) {\n          return JSON.parse(saved);\n        }\n      } catch (e) {\n        console.error(\"Failed to load favorites:\", e);\n      }\n    }\n    return [];\n  });\n  const isInitialMount = useRef(true);\n  const modeRef = useRef(mode);\n  const isApplyingRef = useRef(false);\n\n  // Keep modeRef in sync with mode state\n  useEffect(() => {\n    modeRef.current = mode;\n  }, [mode]);\n\n  const applyTheme = useCallback(\n    async (urlOrCss: string, overrideMode?: \"light\" | \"dark\") => {\n      // Prevent concurrent theme applications\n      if (isApplyingRef.current) {\n        return;\n      }\n      isApplyingRef.current = true;\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        let registryItem: ThemeRegistryItem;\n        let themeName: string;\n        let themeId: string;\n        let themeOption: ThemeOption;\n\n        if (isCssCode(urlOrCss)) {\n          // Handle CSS code\n          registryItem = parseCssToThemeRegistryItem(urlOrCss, \"custom-css-theme\");\n          themeName = registryItem.name;\n          themeId = `css-theme-${Date.now()}`;\n\n          themeOption = {\n            id: themeId,\n            name: themeName,\n            css: urlOrCss,\n          };\n        } else {\n          // Handle URL - normalize editor URLs to JSON URLs\n          const normalizedUrl = normalizeTweakcnUrl(urlOrCss);\n          registryItem = await fetchThemeFromUrl(normalizedUrl);\n          themeName = registryItem.name || extractThemeNameFromUrl(normalizedUrl);\n          themeId = `theme-${themeName}`;\n\n          themeOption = {\n            id: themeId,\n            name: themeName,\n            url: normalizedUrl,\n          };\n        }\n\n        setCurrentRegistryItem(registryItem);\n        const currentMode = overrideMode ?? modeRef.current;\n        await applyThemeFromRegistry(registryItem, currentMode);\n\n        setThemes((prev) => {\n          // Check if theme already exists (by URL or CSS content)\n          // Normalize URLs for comparison\n          const normalizedInputUrl = isCssCode(urlOrCss) ? urlOrCss : normalizeTweakcnUrl(urlOrCss);\n          const existing = prev.find(\n            (t) =>\n              (t.url && normalizeTweakcnUrl(t.url) === normalizedInputUrl) ||\n              (t.css && t.css === urlOrCss),\n          );\n          if (!existing) {\n            const updated = [...prev, themeOption];\n            setCurrentTheme(themeOption);\n            return updated;\n          }\n          setCurrentTheme(existing);\n          return prev;\n        });\n\n        // Persist if enabled\n        if (persist) {\n          localStorage.setItem(\n            storageKey,\n            JSON.stringify({\n              ...(isCssCode(urlOrCss) ? { css: urlOrCss } : { url: themeOption.url }),\n              mode: currentMode,\n              name: themeName,\n            }),\n          );\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : \"Failed to apply theme\";\n        setError(errorMessage);\n        console.error(\"Failed to apply theme:\", err);\n      } finally {\n        setIsLoading(false);\n        isApplyingRef.current = false;\n      }\n    },\n    [persist, storageKey],\n  );\n\n  // Load persisted theme on mount only\n  useEffect(() => {\n    if (persist && isInitialMount.current) {\n      isInitialMount.current = false;\n      const saved = localStorage.getItem(storageKey);\n      if (saved) {\n        try {\n          const savedTheme = JSON.parse(saved);\n          if (savedTheme.mode) {\n            setMode(savedTheme.mode);\n          }\n          if (savedTheme.url || savedTheme.css) {\n            if (savedTheme.css) {\n              // Apply CSS theme\n              applyTheme(savedTheme.css, savedTheme.mode).catch((err) => {\n                console.error(\"Failed to load saved theme:\", err);\n                // Clear invalid saved theme\n                localStorage.removeItem(storageKey);\n              });\n            } else if (savedTheme.url) {\n              // Validate URL before attempting to apply\n              const validation = validateUrl(savedTheme.url);\n              if (validation.valid) {\n                // Apply theme with the saved mode\n                applyTheme(savedTheme.url, savedTheme.mode).catch((err) => {\n                  console.error(\"Failed to load saved theme:\", err);\n                  // Clear invalid saved theme\n                  localStorage.removeItem(storageKey);\n                });\n              } else {\n                // Clear invalid saved theme\n                console.warn(\"Invalid saved theme URL, clearing:\", validation.error);\n                localStorage.removeItem(storageKey);\n              }\n            }\n          }\n        } catch (e) {\n          console.error(\"Failed to load saved theme:\", e);\n          // Clear corrupted saved theme\n          localStorage.removeItem(storageKey);\n        }\n      } else {\n        isInitialMount.current = false;\n      }\n    }\n  }, [persist, storageKey, applyTheme]);\n\n  // Apply mode changes to current theme\n  useEffect(() => {\n    if (currentRegistryItem) {\n      applyThemeFromRegistry(currentRegistryItem, mode).catch(console.error);\n      // Update localStorage with new mode if persist is enabled\n      if (persist && currentTheme) {\n        const saved = localStorage.getItem(storageKey);\n        if (saved) {\n          try {\n            const savedTheme = JSON.parse(saved);\n            localStorage.setItem(\n              storageKey,\n              JSON.stringify({\n                ...savedTheme,\n                mode,\n                ...(currentTheme.css ? { css: currentTheme.css } : {}),\n                ...(currentTheme.url ? { url: currentTheme.url } : {}),\n              }),\n            );\n          } catch (e) {\n            console.error(\"Failed to update saved theme mode:\", e);\n          }\n        }\n      }\n    }\n  }, [mode, currentRegistryItem, persist, storageKey, currentTheme]);\n\n  const applyThemeOption = useCallback(\n    async (theme: ThemeOption) => {\n      // Prevent applying the same theme if it's already the current theme\n      if (currentTheme?.id === theme.id) {\n        return;\n      }\n      // Prevent applying if already loading or applying\n      if (isLoading || isApplyingRef.current) {\n        return;\n      }\n      if (theme.css) {\n        await applyTheme(theme.css);\n      } else if (theme.url) {\n        await applyTheme(theme.url);\n      }\n    },\n    [applyTheme, currentTheme, isLoading],\n  );\n\n  const addTheme = useCallback(\n    async (urlOrCss: string, name?: string): Promise<ThemeOption | null> => {\n      setError(null); // Clear any previous errors\n      try {\n        let registryItem: ThemeRegistryItem;\n        let themeName: string;\n        let themeId: string;\n        let newTheme: ThemeOption;\n\n        if (isCssCode(urlOrCss)) {\n          // Handle CSS code\n          registryItem = parseCssToThemeRegistryItem(urlOrCss, name || \"custom-css-theme\");\n          themeName = name || registryItem.name;\n          themeId = `css-theme-${Date.now()}`;\n\n          newTheme = {\n            id: themeId,\n            name: themeName,\n            css: urlOrCss,\n          };\n        } else {\n          // Handle URL - normalize editor URLs to JSON URLs\n          const normalizedUrl = normalizeTweakcnUrl(urlOrCss);\n          registryItem = await fetchThemeFromUrl(normalizedUrl);\n          themeName = name || registryItem.name || extractThemeNameFromUrl(normalizedUrl);\n          themeId = `theme-${themeName}`;\n\n          newTheme = {\n            id: themeId,\n            name: themeName,\n            url: normalizedUrl,\n          };\n        }\n\n        setThemes((prev) => {\n          // Check if theme already exists (by URL or CSS content)\n          // Normalize URLs for comparison\n          const normalizedInputUrl = isCssCode(urlOrCss) ? urlOrCss : normalizeTweakcnUrl(urlOrCss);\n          if (\n            prev.some(\n              (t) =>\n                (t.url && normalizeTweakcnUrl(t.url) === normalizedInputUrl) ||\n                (t.css && t.css === urlOrCss),\n            )\n          ) {\n            return prev;\n          }\n          return [...prev, newTheme];\n        });\n\n        return newTheme;\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : \"Failed to add theme\";\n        setError(errorMessage);\n        throw err;\n      }\n    },\n    [],\n  );\n\n  const removeTheme = useCallback(\n    (themeId: string) => {\n      setThemes((prev) => prev.filter((t) => t.id !== themeId));\n      if (currentTheme?.id === themeId) {\n        setCurrentTheme(null);\n        setCurrentRegistryItem(null);\n        if (persist) {\n          localStorage.removeItem(storageKey);\n        }\n      }\n    },\n    [currentTheme, persist, storageKey],\n  );\n\n  const handleSetMode = useCallback((newMode: \"light\" | \"dark\") => {\n    setMode(newMode);\n  }, []);\n\n  const toggleFavorite = useCallback(\n    (themeId: string) => {\n      setFavorites((prev) => {\n        const newFavorites = prev.includes(themeId)\n          ? prev.filter((id) => id !== themeId)\n          : [...prev, themeId];\n\n        // Persist favorites\n        if (persist && typeof window !== \"undefined\") {\n          try {\n            localStorage.setItem(favoritesKey, JSON.stringify(newFavorites));\n          } catch (e) {\n            console.error(\"Failed to save favorites:\", e);\n          }\n        }\n\n        return newFavorites;\n      });\n    },\n    [persist, favoritesKey],\n  );\n\n  const isFavorite = useCallback(\n    (themeId: string) => {\n      return favorites.includes(themeId);\n    },\n    [favorites],\n  );\n\n  return {\n    currentTheme,\n    themes,\n    isLoading,\n    error,\n    applyTheme,\n    applyThemeOption,\n    addTheme,\n    removeTheme,\n    mode,\n    setMode: handleSetMode,\n    favorites,\n    toggleFavorite,\n    isFavorite,\n  };\n}\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/tweakcn-switcher/types.ts",
      "content": "/**\n * Type definitions for shadcn/ui theme registry format\n */\n\nexport interface ThemeRegistryCssVars {\n  theme?: Record<string, string>;\n  light?: Record<string, string>;\n  dark?: Record<string, string>;\n}\n\nexport interface ThemeRegistryItem {\n  $schema?: string;\n  name: string;\n  type: string;\n  css?: {\n    \"@layer base\"?: Record<string, Record<string, string>>;\n  };\n  cssVars: ThemeRegistryCssVars;\n}\n\nexport interface ThemeOption {\n  id: string;\n  name: string;\n  url?: string;\n  css?: string;\n  preview?: string;\n}\n\nexport interface TweakcnSwitcherConfig {\n  defaultThemes?: ThemeOption[];\n  baseUrl?: string;\n  persist?: boolean;\n  storageKey?: string;\n  allowDeleteDefaults?: boolean;\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/tweakcn-switcher/utils.ts",
      "content": "/**\n * Utility functions for applying theme CSS variables\n */\n\nimport type { ThemeRegistryItem, ThemeRegistryCssVars } from \"./types\";\n\nfunction applyCSSVariable(\n  key: string,\n  value: string,\n  root: HTMLElement = document.documentElement,\n) {\n  // Use setProperty for CSS custom properties\n  root.style.setProperty(`--${key}`, value);\n}\n\n/**\n * Remove all font links added by tweakcn-switcher\n */\nfunction removeFontLinks() {\n  const existing = document.querySelectorAll('link[data-tweakcn-switcher-font=\"true\"]');\n  existing.forEach((el) => el.remove());\n}\n\n/**\n * Extract font family names from a font-family CSS value\n * Handles values like \"Roboto, sans-serif\" or '\"Inter Variable\", sans-serif'\n */\nfunction extractFontNames(fontFamily: string): string[] {\n  // Remove quotes and split by comma\n  const fonts = fontFamily\n    .split(\",\")\n    .map((f) => f.trim().replace(/^[\"']|[\"']$/g, \"\"))\n    .filter((f) => f && !f.match(/^(sans-serif|serif|monospace| cursive|fantasy)$/i));\n\n  return fonts;\n}\n\n/**\n * Try to load a font from Google Fonts\n * Returns the Google Fonts URL if successful, null otherwise\n */\nfunction getGoogleFontsUrl(fontName: string): string | null {\n  // Remove spaces and special characters for Google Fonts API\n  const normalizedName = fontName.replace(/\\s+/g, \"+\").replace(/['\"]/g, \"\").trim();\n\n  if (!normalizedName) {\n    return null;\n  }\n\n  // Google Fonts API URL\n  return `https://fonts.googleapis.com/css2?family=${normalizedName}:wght@400;500;600;700&display=swap`;\n}\n\n/**\n * Load a font from Google Fonts URL\n */\nfunction loadGoogleFont(url: string): Promise<void> {\n  return new Promise<void>((resolve) => {\n    // Check if link already exists\n    const existing = document.querySelector(`link[href=\"${url}\"]`);\n    if (existing) {\n      resolve();\n      return;\n    }\n\n    const link = document.createElement(\"link\");\n    link.rel = \"stylesheet\";\n    link.href = url;\n    link.setAttribute(\"data-tweakcn-switcher-font\", \"true\");\n\n    link.onload = () => resolve();\n    link.onerror = () => {\n      // Silently fail - let the dev handle it if needed\n      resolve();\n    };\n\n    document.head.appendChild(link);\n  });\n}\n\n/**\n * Try to load fonts from Google Fonts based on font-family value\n * This is best-effort - if it fails, the dev can handle it\n */\nasync function tryLoadFontsFromGoogleFonts(fontFamily: string): Promise<void> {\n  const fontNames = extractFontNames(fontFamily);\n\n  if (fontNames.length === 0) {\n    return;\n  }\n\n  // Try to load each font from Google Fonts\n  const loadPromises = fontNames.map((fontName) => {\n    const googleFontsUrl = getGoogleFontsUrl(fontName);\n    if (googleFontsUrl) {\n      return loadGoogleFont(googleFontsUrl);\n    }\n    return Promise.resolve();\n  });\n\n  await Promise.all(loadPromises);\n}\n\nexport async function applyThemeFromRegistry(\n  registryItem: ThemeRegistryItem,\n  mode: \"light\" | \"dark\" = \"light\",\n) {\n  const root = document.documentElement;\n  const { cssVars, css } = registryItem;\n\n  // Remove existing font variable override styles\n  const existingFontStyle = document.querySelector('style[data-tweakcn-switcher-font-vars=\"true\"]');\n  if (existingFontStyle) {\n    existingFontStyle.remove();\n  }\n\n  // Apply theme-level variables (common to both light and dark)\n  let fontSansValue: string | null = null;\n  if (cssVars.theme) {\n    Object.entries(cssVars.theme).forEach(([key, value]) => {\n      applyCSSVariable(key, value, root);\n\n      // Track font-sans value for special handling\n      if (key === \"font-sans\" && value) {\n        fontSansValue = value;\n      }\n    });\n  }\n\n  // Try to load fonts from Google Fonts if font-sans is set\n  if (fontSansValue) {\n    // Try to load from Google Fonts (best-effort, fails silently)\n    await tryLoadFontsFromGoogleFonts(fontSansValue).catch(() => {\n      // Silently fail - let the dev handle font loading if needed\n    });\n\n    // Inject a style to override Tailwind's @theme variable with higher specificity\n    const fontStyle = document.createElement(\"style\");\n    fontStyle.setAttribute(\"data-tweakcn-switcher-font-vars\", \"true\");\n    // Escape any quotes in the font value for CSS\n    const escapedFontValue = (fontSansValue as string).replace(/\"/g, '\\\\\"');\n    fontStyle.textContent = `\n      :root {\n        --font-sans: ${escapedFontValue} !important;\n      }\n      html, body {\n        font-family: ${escapedFontValue} !important;\n      }\n    `;\n    document.head.appendChild(fontStyle);\n  } else {\n    // If no font-sans in theme, remove any inline font-family styles we may have set\n    removeFontLinks();\n    root.style.removeProperty(\"font-family\");\n    if (document.body) {\n      document.body.style.removeProperty(\"font-family\");\n    }\n  }\n\n  // Apply mode-specific variables (excluding theme-level variables)\n  const modeVars = cssVars[mode];\n  if (modeVars) {\n    Object.entries(modeVars).forEach(([key, value]) => {\n      // Skip theme-level variables (radius, font-*, shadow, tracking-*, spacing)\n      // These should only come from cssVars.theme\n      if (\n        !key.startsWith(\"font-\") &&\n        !key.startsWith(\"radius\") &&\n        !key.startsWith(\"shadow\") &&\n        !key.startsWith(\"tracking-\") &&\n        !key.startsWith(\"spacing\")\n      ) {\n        applyCSSVariable(key, value, root);\n      }\n    });\n  }\n\n  // Apply CSS layer base styles if present\n  if (css?.[\"@layer base\"]) {\n    // Remove existing style elements\n    const existing = document.querySelectorAll('style[data-tweakcn-switcher=\"true\"]');\n    existing.forEach((el) => el.remove());\n\n    const baseStyles = css[\"@layer base\"];\n    const styleElement = document.createElement(\"style\");\n    styleElement.setAttribute(\"data-tweakcn-switcher\", \"true\");\n\n    // Combine all selectors into one style element\n    const styleContent = Object.entries(baseStyles)\n      .map(([selector, styles]) => {\n        const props = Object.entries(styles)\n          .map(([prop, val]) => `${prop}: ${val};`)\n          .join(\" \");\n        return `${selector} { ${props} }`;\n      })\n      .join(\"\\n\");\n\n    styleElement.textContent = `@layer base {\\n${styleContent}\\n}`;\n    document.head.appendChild(styleElement);\n  }\n\n  if (mode === \"dark\") {\n    root.classList.add(\"dark\");\n  } else {\n    root.classList.remove(\"dark\");\n  }\n}\n\n/**\n * Validates if a string is a valid URL\n * Handles malformed URIs gracefully\n */\nexport function validateUrl(url: string): { valid: boolean; error?: string } {\n  if (!url || typeof url !== \"string\" || url.trim().length === 0) {\n    return { valid: false, error: \"URL cannot be empty\" };\n  }\n\n  const trimmedUrl = url.trim();\n\n  // Try to create a URL object to validate\n  try {\n    // Attempt to decode URI components first to catch malformed sequences\n    try {\n      decodeURIComponent(trimmedUrl);\n    } catch (_e) {\n      return {\n        valid: false,\n        error: \"Invalid URL: contains malformed characters. Please check the URL and try again.\",\n      };\n    }\n\n    // Validate URL structure\n    const urlObj = new URL(trimmedUrl);\n\n    // Ensure it's http or https\n    if (![\"http:\", \"https:\"].includes(urlObj.protocol)) {\n      return {\n        valid: false,\n        error: \"URL must use http or https protocol\",\n      };\n    }\n\n    return { valid: true };\n  } catch (e) {\n    // If URL constructor throws, it's invalid\n    if (e instanceof TypeError) {\n      return {\n        valid: false,\n        error:\n          \"Invalid URL format. Please enter a valid URL (e.g., https://example.com/theme.json)\",\n      };\n    }\n    // Handle URI malformed errors\n    if (e instanceof URIError) {\n      return {\n        valid: false,\n        error: \"Invalid URL: contains malformed characters. Please check the URL and try again.\",\n      };\n    }\n    return {\n      valid: false,\n      error: \"Invalid URL format\",\n    };\n  }\n}\n\n/**\n * Normalizes tweakcn.com editor URLs to theme JSON URLs\n * Transforms: https://tweakcn.com/editor/theme?theme=candyland\n * To: https://tweakcn.com/r/themes/candyland.json\n */\nexport function normalizeTweakcnUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    \n    // Check if it's a tweakcn.com editor URL with a theme query parameter\n    if (\n      urlObj.hostname === \"tweakcn.com\" &&\n      urlObj.pathname === \"/editor/theme\" &&\n      urlObj.searchParams.has(\"theme\")\n    ) {\n      const themeName = urlObj.searchParams.get(\"theme\");\n      if (themeName) {\n        // Transform to the theme JSON URL format\n        return `https://tweakcn.com/r/themes/${themeName}.json`;\n      }\n    }\n    \n    // Return the original URL if it doesn't match the pattern\n    return url;\n  } catch {\n    // If URL parsing fails, return the original URL\n    return url;\n  }\n}\n\nexport async function fetchThemeFromUrl(url: string): Promise<ThemeRegistryItem> {\n  // Normalize the URL first (transform editor URLs to theme JSON URLs)\n  const normalizedUrl = normalizeTweakcnUrl(url);\n  \n  // Validate URL first\n  const validation = validateUrl(normalizedUrl);\n  if (!validation.valid) {\n    throw new Error(validation.error || \"Invalid URL\");\n  }\n\n  try {\n    const response = await fetch(normalizedUrl);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch theme: ${response.statusText} (${response.status})`);\n    }\n    return response.json();\n  } catch (e) {\n    // Handle network errors and malformed URI errors\n    if (e instanceof TypeError && e.message.includes(\"Failed to fetch\")) {\n      throw new Error(\n        \"Network error: Unable to fetch theme. Please check your connection and the URL.\",\n      );\n    }\n    if (e instanceof URIError) {\n      throw new Error(\n        \"Invalid URL: contains malformed characters. Please check the URL and try again.\",\n      );\n    }\n    // Re-throw if it's already an Error with a message\n    if (e instanceof Error) {\n      throw e;\n    }\n    throw new Error(\"Failed to fetch theme: Unknown error occurred\");\n  }\n}\n\nexport function extractThemeNameFromUrl(url: string): string {\n  try {\n    const match = url.match(/\\/([^/]+)\\.json$/);\n    if (match && match[1]) {\n      // Try to decode the theme name if it's URL encoded\n      try {\n        return decodeURIComponent(match[1]);\n      } catch {\n        // If decoding fails, return the raw match\n        return match[1];\n      }\n    }\n    return \"custom-theme\";\n  } catch {\n    // If anything goes wrong, return a safe default\n    return \"custom-theme\";\n  }\n}\n\n/**\n * Parses CSS code and converts it to a ThemeRegistryItem\n * Supports :root, .dark, and @theme inline selectors\n */\nexport function parseCssToThemeRegistryItem(\n  css: string,\n  name: string = \"custom-css-theme\",\n): ThemeRegistryItem {\n  const cssVars: ThemeRegistryCssVars = {\n    theme: {},\n    light: {},\n    dark: {},\n  };\n\n  // Remove comments\n  const cleanedCss = css.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n\n  // Parse :root selector (light mode variables)\n  const rootMatch = cleanedCss.match(/:root\\s*\\{([^}]+)\\}/);\n  if (rootMatch && rootMatch[1]) {\n    const rootContent = rootMatch[1];\n    const varMatches = rootContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Determine if it's a theme-level variable or light mode variable\n        // Theme-level variables are things like --radius, --font-*, --shadow-*, etc.\n        if (\n          key.startsWith(\"font-\") ||\n          key.startsWith(\"radius\") ||\n          key.startsWith(\"shadow\") ||\n          key.startsWith(\"tracking-\") ||\n          key.startsWith(\"spacing\")\n        ) {\n          cssVars.theme![key] = value;\n        } else {\n          cssVars.light![key] = value;\n        }\n      }\n    }\n  }\n\n  // Parse .dark selector (dark mode variables)\n  const darkMatch = cleanedCss.match(/\\.dark\\s*\\{([^}]+)\\}/);\n  if (darkMatch && darkMatch[1]) {\n    const darkContent = darkMatch[1];\n    const varMatches = darkContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Dark mode variables (excluding theme-level ones)\n        if (\n          !key.startsWith(\"font-\") &&\n          !key.startsWith(\"radius\") &&\n          !key.startsWith(\"shadow\") &&\n          !key.startsWith(\"tracking-\") &&\n          !key.startsWith(\"spacing\")\n        ) {\n          cssVars.dark![key] = value;\n        }\n      }\n    }\n  }\n\n  // Parse @theme inline block if present\n  const themeInlineMatch = cleanedCss.match(/@theme\\s+inline\\s*\\{([^}]+)\\}/);\n  const cssLayerBase: Record<string, Record<string, string>> = {};\n  if (themeInlineMatch && themeInlineMatch[1]) {\n    const themeContent = themeInlineMatch[1];\n    const varMatches = themeContent.matchAll(/--([^:]+):\\s*([^;]+);/g);\n    for (const match of varMatches) {\n      if (match[1] && match[2]) {\n        const key = match[1].trim();\n        const value = match[2].trim();\n        // Check if it's a theme-level variable (radius, font, shadow, etc.)\n        if (\n          key.startsWith(\"font-\") ||\n          key.startsWith(\"radius\") ||\n          key.startsWith(\"shadow\") ||\n          key.startsWith(\"tracking-\") ||\n          key.startsWith(\"spacing\")\n        ) {\n          // Add to theme-level variables\n          cssVars.theme![key] = value;\n        } else {\n          // These are typically color mappings, add to :root in @layer base\n          if (!cssLayerBase[\":root\"]) {\n            cssLayerBase[\":root\"] = {};\n          }\n          cssLayerBase[\":root\"][`--${key}`] = value;\n        }\n      }\n    }\n  }\n\n  return {\n    name,\n    type: \"theme\",\n    cssVars,\n    ...(Object.keys(cssLayerBase).length > 0 && {\n      css: {\n        \"@layer base\": cssLayerBase,\n      },\n    }),\n  };\n}\n\n/**\n * Checks if a string is likely CSS code (contains CSS selectors or properties)\n */\nexport function isCssCode(input: string): boolean {\n  const trimmed = input.trim();\n  // If it's a valid URL, it's not CSS\n  const urlValidation = validateUrl(trimmed);\n  if (urlValidation.valid) {\n    return false;\n  }\n  // Check for CSS indicators\n  return (\n    trimmed.includes(\":root\") ||\n    trimmed.includes(\".dark\") ||\n    trimmed.includes(\"@theme\") ||\n    trimmed.includes(\"--\") ||\n    (trimmed.includes(\"{\") && trimmed.includes(\"}\") && trimmed.includes(\":\"))\n  );\n}\n\nexport interface ColorSwatch {\n  name: string;\n  value: string;\n}\n\n/**\n * Extract color swatches from a theme registry item\n * Returns an array of color swatches with variable names and values\n */\nexport function extractColorSwatches(\n  registryItem: ThemeRegistryItem,\n  mode: \"light\" | \"dark\" = \"light\",\n): ColorSwatch[] {\n  const colors: ColorSwatch[] = [];\n  const modeVars = registryItem.cssVars[mode] || {};\n  const usedValues = new Set<string>();\n\n  // Priority order for color extraction\n  const colorKeys = [\n    \"background\",\n    \"foreground\",\n    \"primary\",\n    \"secondary\",\n    \"accent\",\n    \"muted\",\n    \"destructive\",\n    \"border\",\n    \"ring\",\n    \"card\",\n    \"popover\",\n  ];\n\n  for (const key of colorKeys) {\n    if (modeVars[key] && !usedValues.has(modeVars[key])) {\n      colors.push({ name: key, value: modeVars[key] });\n      usedValues.add(modeVars[key]);\n    }\n  }\n\n  // If we don't have enough colors, add any remaining color variables\n  if (colors.length < 8) {\n    for (const [key, value] of Object.entries(modeVars)) {\n      if (\n        !usedValues.has(value) &&\n        !key.startsWith(\"font-\") &&\n        !key.startsWith(\"radius\") &&\n        !key.startsWith(\"shadow\") &&\n        !key.startsWith(\"tracking-\") &&\n        !key.startsWith(\"spacing\")\n      ) {\n        colors.push({ name: key, value });\n        usedValues.add(value);\n        if (colors.length >= 8) break;\n      }\n    }\n  }\n\n  return colors.slice(0, 8); // Return up to 8 colors\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:component"
}